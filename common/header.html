<script type="text/discourse-plugin" version="0.8">
  const topBarHeight = 60; // FIXME: Determine this dynamically
  class GraphObject {
    constructor(dotSrcs, optionsObjects, isEditorPreview, replyControl) {
      this.dotSrcs = dotSrcs;
      this.optionsObjects = optionsObjects;
      this.textBefore = '';
      this.textAfter = '';
      this.isEditorPreview = isEditorPreview;
      this.replyControl = replyControl;
      this._selection = null;
      this.graphObjects = null;
      this.graphIndex = null;
      this.graphviz = null;
      this.index = 0;
      this.run = false;
      this.minWidth = 0;
      this.minHeight = 0;
      this.running = false;
      this.visible;
      this.loop = true;
      this.startStopButton;
    }
    set selection(selection) {
      this._selection = selection;
      this.element = selection.node();
    }
    get selection() {
      return this._selection;
   }
    get dotSrc() {
      return this.dotSrcs[this.index];
    }
    get options() {
      return this.optionsObjects[this.index];
    }

    init() {
      this.initGraphviz();
      this.initVisibilityChangeHandler();
      if (this.dotSrcs.length > 1) {
        this.run = !this.isEditorPreview;
        this.addControls();
      }
      this.visible = this.isVisible();

      this.render();
    }

    initGraphviz() {
      this.graphviz = this._selection.graphviz({useWorker: this.options.useWorker})
        .options(this.options)
        .attributer(attributer)
        .on('end', this.done.bind(this));

      const graphObject = this;
      function attributer(datum, index, nodes) {
        if (datum.tag == "svg") {
          const border = graphObject.options.border;
          const style = graphObject.options.style;
          var svg = d3.select(this);
          if (svg.attr('xmlns') != null) {
            let widthAttr = datum.attributes.width;
            let width = typeof widthAttr == 'string' && widthAttr.includes('pt') ?
                widthAttr.replace('pt', '') * 4 / 3 :
                +widthAttr;
            let heightAttr = datum.attributes.height;
            let height = typeof heightAttr == 'string' && heightAttr.includes('pt') ?
                heightAttr.replace('pt', '') * 4 / 3 :
                +heightAttr;
            if (width > graphObject.minWidth) {
              graphObject.minWidth = width;
            }
            else {
              width = graphObject.minWidth;
            }
            if (height > graphObject.minHeight) {
              graphObject.minHeight = height;
              height = svg.attr('height').split(' ');
            }
            else {
              height = graphObject.minHeight;
            }

            const newViewBoxValues = datum.attributes.viewBox.split(' ');
            const viewBoxValues = svg.attr('viewBox').split(' ');
            viewBoxValues[2] = width * 3 / 4;
            newViewBoxValues[2] = graphObject.minWidth * 3 / 4;
            viewBoxValues[3] = height * 3 / 4;
            newViewBoxValues[3] = graphObject.minHeight * 3 / 4;

            const viewBox = viewBoxValues.join(' ');
            const newViewBox = newViewBoxValues.join(' ');

            svg
              .attr("style", style)
              .style("border", border)
              .attr("width", width)
              .attr("height", height)
              .attr("viewBox", viewBox);

            datum.attributes.width = graphObject.minWidth;
            datum.attributes.height = graphObject.minHeight;
            datum.attributes.viewBox = newViewBox;
          }
          datum.attributes.style = 'border: ' + border + ';' + style;
        }
      }
    }

    addControls() {
      this.startStopButton = this.selection
        .append('div')
        .append('button')
        .attr('class', 'btn-primary')
        .style('margin-top', '15px')
        .style('margin-bottom', '15px')
        .on('click', this.startStop.bind(this))
        .text(this.run ? 'Stop' : 'Start');
    }

    render() {
      this.running = true;
      const options = this.options;
      const dotSrc = this.dotSrc;
      if (this.index < this.dotSrcs.length) {
        this.graphviz
          .options(options)
          .renderDot(dotSrc);
      }
    }

    done() {
      const svg = this.selection.selectAll('svg');
      const widthAttr = svg.attr('width');
      const heightAttr = svg.attr('height');
      let width = widthAttr.includes('pt') ? width = widthAttr.replace('pt', '') * 4 / 3 : +widthAttr;
      let height = heightAttr.includes('pt') ? height = heightAttr.replace('pt', '') * 4 / 3 : +heightAttr;
      if (width > this.minWidth) {
        this.minWidth = width;
      }
      if (height > this.minHeight) {
        this.minHeight = height;
      }
      this.index = (this.index + 1) % this.dotSrcs.length;
      this.visible = this.isVisible();
      this.running = false;
      if (this.dotSrcs.length > 1) {
        const options = this.options;
        const delay = options.delay || 500;
        const duration = options.duration || 1500;
        let ease;
        if (options.ease == 'linear') {
          ease = d3.easeLinear
        }
        else {
          ease = d3.easeCubic
        }
        this.graphviz
          .transition(() => d3.transition()
                      .ease(ease)
                      .delay(delay)
                      .duration(duration));
      }
      if (this.run && (this.index > 0 || this.loop)) {
        const editorPreviewIsOpen = this.replyControl.classList.contains('open');
        if (this.visible && (this.isEditorPreview || !editorPreviewIsOpen)) {
          this.running = true;
          this.render();
        } else {
          const observer = new MutationObserver((mutations) => {
            this.visible = this.isVisible();
            if (this.visible) {
              this.renderext();
            }
          });
          observer.observe(this.replyControl, {childList: true});
        }
      }
    }

    startStop() {
      console.log(this.run ? 'Stop' : 'Start');
      this.run = !this.run;
      this.startStopButton.text(this.run ? 'Stop' : 'Start');
      if (!this.running) {
        this.render();
      }
    }

    isVisible() {
      const bounding = this.element.getBoundingClientRect();
      if (document.hidden) {
        return false;
      }
      else if (bounding.top >= topBarHeight && bounding.bottom <= window.innerHeight) {
        // The whole graph is visible
        return true;
      }
      else if (bounding.top <= topBarHeight && bounding.bottom >= window.innerHeight) {
        // The graph covers the whole visible area
        return true;
      }
      else if (bounding.top >= topBarHeight && bounding.top <= window.innerHeight) {
        // The top of the graph is visible
        if (this.graphIndex == 0) {
          // It's the first graph
          return true;
        }
        const prevGraph = this.graphObjects[this.graphIndex - 1].element;
        const prevBounding = prevGraph.getBoundingClientRect();
        if (prevBounding.bottom > 0) {
          // The bottom of the previous graph is also visible
          return false;
        }
        return true;
      }
      else if (bounding.bottom >= topBarHeight && bounding.bottom <= window.innerHeight) {
        // The bottom of the graph is visible
        if (this.graphIndex == this.graphObjects.length - 1) {
          // It's the last graph
          return true;
        }
        const nextGraph = this.graphObjects[this.graphIndex + 1].element;
        const nextBounding = nextGraph.getBoundingClientRect();
        if (nextBounding.top <= window.innerHeight) {
          // The top of the next graph is also visible
          return false;
        }
        return true;
      }
      else {
        return false;
      }
    }

    initVisibilityChangeHandler() {
      document.addEventListener('visibilitychange', this.visibilityChangeHandler.bind(this));
      window.addEventListener('scroll', this.visibilityChangeHandler.bind(this));
    }

    visibilityChangeHandler() {
      const wasVisible = this.visible;
      this.visible = this.isVisible();
      if (!wasVisible && this.visible) {
        if (!this.running) {
          this.render();
        }
      }
    }

  }

  const graphObjects = [];
  // For each post
  api.decorateCooked($elem => {
    const cookedDiv = $elem.get(0);
    const replyControl = d3.select('#reply-control').node();
    const isEditorPreview = d3.select(cookedDiv).classed('d-editor-preview');
    const $paragraphs = $elem.children('p');
    // For each paragraph in post
    let partialParagraphText = '';
    $.each($paragraphs, (paragraphIndex, paragraph) => {

      let graphObject;
      retrieveGraphObject();
      if (!graphObject) {
        return;
      }

      createGraphArea();
      graphObject.graphIndex = graphObjects.length;
      graphObjects.push(graphObject);
      graphObject.graphObjects = graphObjects;
      graphObject.init();

      function retrieveGraphObject() {
        let text = partialParagraphText + paragraph.innerText;
        let textBefore = '';
        partialParagraphText = '';
        let dotSrcs = text.split('[dot')
          .slice(1)
        if (dotSrcs.length == 0) {
          return;
        }
        if (dotSrcs.length > 0 && !dotSrcs[dotSrcs.length - 1].includes('[/dot]')) {
          partialParagraphText = text;
          return;
        }
        const optionsObjects = [];
        for (const dotSrc of dotSrcs) {
          const optionsObject = Object.assign(
            {},
            optionsObjects.length == 0 ? {useWorker: true} : optionsObjects[optionsObjects.length - 1]
          );
          attributes=dotSrc.split(']')[0].match(/ *[^ \]]*=(“[^”]*”|[^ \]]*|\([^\)]*\))/g) || [];
          for (attribute of attributes) {
            const [name, value] = attribute.trim().replace(/[“”]/g, '').split('=')
            if (value == 'true') {
              value = true;
            }
            else if (value == 'false') {
              value = false;
            }
            else if (!isNaN(value)) {
              value = Number(value);
            }
            else if (value[0] == '(') {
              if (value[1] == '(') {
                value = value.slice(2, -2).split('),(').map(a => a.split(',').map(v => Number(v)));
              }
              else {
                value = value.slice(1, -1).split(',').map(v => Number(v))
              }
            }
            optionsObject[name] = value;
          }
          if (optionsObject.hasOwnProperty('tweenPrecision') && optionsObject.tweenPrecision < 1) {
            optionsObject.tweenPrecision = 1;
          }
          optionsObjects.push(optionsObject);
          textBefore = textBefore + text.slice(0, text.indexOf('[dot'));
          text = text.slice(text.indexOf('[/dot]') + '[/dot]'.length);
        }
        textAfter = text;
        dotSrcs = dotSrcs
          .map(dotSrc => dotSrc.slice(0, dotSrc.indexOf('[/dot]')).replace(/[^\]]*]/, '').trim());
        graphObject = new GraphObject(dotSrcs, optionsObjects, isEditorPreview, replyControl);
        graphObject.textBefore = textBefore;
        graphObject.textAfter = textAfter;
      }

      function createGraphArea() {
        d3.select(paragraph).text('');
        if (graphObject.textBefore != '') {
          d3.select(paragraph).append('span').text(graphObject.textBefore);
        }
        const graph = d3.select(paragraph).append('span');
        if (graphObject.textAfter != '') {
          d3.select(paragraph).append('span').text(graphObject.textAfter);
        }
        const graphId = 'graph_' + paragraphIndex;
        graph.attr('id', graphId);
        if (graphObject.optionsObjects[0].verbose) {
          graph
            .append('code')
              .text(graphObject.dotSrcs.join('\n'));
        }
        graphObject.selection = graph;
      }

    });
  },
  {
    id: "dot",
  },
  );

</script>
