<script type="text/discourse-plugin" version="0.8">
  const topBarHeight = 60; // FIXME: Determine this dynamically
  const graphs = [];
  // For each post
  api.decorateCooked($elem => {
    const $paragraphs = $elem.children('p');
    // For each paragraph in post
    let partialParagraphText = '';
    $.each($paragraphs, (paragraphIndex, paragraph) => {

      let dotSrcs;
      const optionsObjects = [];
      retrieveDotSources();
      if (dotSrcs.length == 0) {
        return;
      }

      let graph;
      let graphviz
      let startStopButton;
      let run = false;
      createGraphArea();
      const graphIndex = graphs.length;
      graphs.push(graph);
      initGraphviz();
      initVisibilityChangeHandler();
      if (dotSrcs.length > 1) {
        addControls();
        run = true;
      }

      let dotSrcIndex = 0;
      let minWidth = 0;
      let minHeight = 0;
      let running = false;
      let visible = graphIsVisible();
      let loop = true;

      render();

      function retrieveDotSources() {
        const text = partialParagraphText + paragraph.innerText;
        partialParagraphText = '';
        dotSrcs = text.split('[dot')
          .slice(1)
        if (dotSrcs.length > 0 && !dotSrcs[dotSrcs.length - 1].includes('[/dot]')) {
          partialParagraphText = text;
          dotSrcs = []
          return;
        }
        for (const dotSrc of dotSrcs) {
          const optionsObject = Object.assign(
            {},
            optionsObjects.length == 0 ? {useWorker: true} : optionsObjects[optionsObjects.length - 1]
          );
          attributes=dotSrc.split(']')[0].match(/ *[^ \]]*=(“[^”]*”|[^ \]]*|\([^\)]*\))/g) || [];
          for (attribute of attributes) {
            const [name, value] = attribute.trim().replace(/[“”]/g, '').split('=')
            if (value == 'true') {
              value = true;
            }
            else if (value == 'false') {
              value = false;
            }
            else if (!isNaN(value)) {
              value = Number(value);
            }
            else if (value[0] == '(') {
              if (value[1] == '(') {
                value = value.slice(2, -2).split('),(').map(a => a.split(',').map(v => Number(v)));
              }
              else {
                value = value.slice(1, -1).split(',').map(v => Number(v))
              }
            }
            optionsObject[name] = value;
          }
          if (optionsObject.hasOwnProperty('tweenPrecision') && optionsObject.tweenPrecision < 1) {
            optionsObject.tweenPrecision = 1;
          }
          optionsObjects.push(optionsObject);
        }
        dotSrcs = dotSrcs
          .map(dotSrc => dotSrc.replace(/[^\]]*]/, '').replace('[/dot]', '').trim());
      }

      function createGraphArea() {
        graph = d3.select(paragraph).append('div');
        const graphId = 'graph_' + paragraphIndex;
        graph.attr('id', graphId);
      }

      function initGraphviz() {
        graphviz = graph.graphviz({useWorker: optionsObjects[0].useWorker})
          .options(optionsObjects[0])
          .attributer(attributer)
          .fit(false)
          .on('end', done);
        return graphviz;
      }

      function addControls() {
        startStopButton = graph
          .append('div')
          .append('button')
          .attr('class', 'btn-primary')
          .style('margin-top', '15px')
          .style('margin-bottom', '15px')
          .on('click', startStop)
          .text('Stop');
      }

      function attributer(datum, index, nodes) {
        if (datum.tag == "svg") {
          const options = optionsObjects[dotSrcIndex];
          const border = options.border;
          var svg = d3.select(this);
          if (svg.attr('xmlns') != null) {
            let widthAttr = datum.attributes.width;
            let width = widthAttr.includes('pt') ? widthAttr.replace('pt', '') * 4 / 3 : +widthAttr;
            let heightAttr = datum.attributes.height;
            let height = heightAttr.includes('pt') ? heightAttr.replace('pt', '') * 4 / 3 : +heightAttr;
            if (width > minWidth) {
              minWidth = width;
            }
            else {
              width = minWidth;
            }
            if (height > minHeight) {
              minHeight = height;
              height = svg.attr('height').split(' ');
            }
            else {
              height = minHeight;
            }

            const newViewBoxValues = datum.attributes.viewBox.split(' ');
            const viewBoxValues = svg.attr('viewBox').split(' ');
            viewBoxValues[2] = width * 3 / 4;
            newViewBoxValues[2] = minWidth * 3 / 4;
            viewBoxValues[3] = height * 3 / 4;
            newViewBoxValues[3] = minHeight * 3 / 4;

            const viewBox = viewBoxValues.join(' ');
            const newViewBox = newViewBoxValues.join(' ');

            svg
              .attr("border", border)
              .attr("width", width)
              .attr("height", height)
              .attr("viewBox", viewBox);

            datum.attributes.width = minWidth;
            datum.attributes.height = minHeight;
            datum.attributes.viewBox = newViewBox;
          }
          datum.attributes.style = 'border: ' + border;
        }
      }

      function render() {
        running = true;
        const options = optionsObjects[dotSrcIndex];
        const dotSrc = dotSrcs[dotSrcIndex];
        if (dotSrcIndex < dotSrcs.length) {
          graphviz
            .options(options)
            .renderDot(dotSrc);
        }
      }

      function done() {
        const svg = graph.selectAll('svg');
        const widthAttr = svg.attr('width');
        const heightAttr = svg.attr('height');
        let width = widthAttr.includes('pt') ? width = widthAttr.replace('pt', '') * 4 / 3 : +widthAttr;
        let height = heightAttr.includes('pt') ? height = heightAttr.replace('pt', '') * 4 / 3 : +heightAttr;
        if (width > minWidth) {
          minWidth = width;
        }
        if (height > minHeight) {
          minHeight = height;
        }
        dotSrcIndex = (dotSrcIndex + 1) % dotSrcs.length;
        visible = graphIsVisible();
        if (run && visible && dotSrcs.length > 1 && (dotSrcIndex > 0 || loop)) {
          const options = optionsObjects[dotSrcIndex];
          const delay = options.delay || 500;
          const duration = options.duration || 1500;
          let ease;
          if (options.ease == 'linear') {
            ease = d3.easeLinear
          }
          else {
            ease = d3.easeCubic
          }
          graphviz
            .transition(() => d3.transition()
                        .ease(ease)
                        .delay(delay)
                        .duration(duration));
          render();
        } else {
          running = false;
        }
      }

      function startStop() {
        console.log(run ? 'Stop' : 'Start');
        run = !run;
        startStopButton.text(run ? 'Stop' : 'Start');
        if (!running) {
          render();
        }
      }

      function graphIsVisible() {
        const bounding = graph.node().getBoundingClientRect();
        if (document.hidden) {
          return false;
        }
        else if (bounding.top >= topBarHeight && bounding.bottom <= window.innerHeight) {
          // The whole graph is visible
          return true;
        }
        else if (bounding.top <= topBarHeight && bounding.bottom >= window.innerHeight) {
          // The graph covers the whole visible area
          return true;
        }
        else if (bounding.top >= topBarHeight && bounding.top <= window.innerHeight) {
          // The top of the graph is visible
          if (graphIndex == 0) {
            // It's the first graph
            return true;
          }
          const prevGraph = graphs[graphIndex - 1];
          const prevBounding = prevGraph.node().getBoundingClientRect();
          if (prevBounding.bottom > 0) {
            // The bottom of the previous graph is also visible
            return false;
          }
          return true;
        }
        else if (bounding.bottom >= topBarHeight && bounding.bottom <= window.innerHeight) {
          // The bottom of the graph is visible
          if (graphIndex == graphs.length - 1) {
            // It's the last graph
            return true;
          }
          const nextGraph = graphs[graphIndex + 1];
          const nextBounding = nextGraph.node().getBoundingClientRect();
          if (nextBounding.top <= window.innerHeight) {
            // The top of the next graph is also visible
            return false;
          }
          return true;
        }
        else {
          return false;
        }
      }

      function initVisibilityChangeHandler() {
        document.addEventListener('visibilitychange', visibilityChangeHandler);
        window.addEventListener('scroll', visibilityChangeHandler);
      }

      function visibilityChangeHandler() {
        const wasVisible = visible;
        visible = graphIsVisible();
        if (!wasVisible && visible) {
          if (!running) {
            render();
          }
        }
      }

    });
  },
  {
    id: "dot",
  },
  );

</script>
